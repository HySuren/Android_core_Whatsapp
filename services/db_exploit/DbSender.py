import datetime
import random

from services.db_exploit.SqlExecutor import SqlExecutor
from iterator_models import DbInfo as i


class DbSender(SqlExecutor):
    """Класс по работе с базой whatsapp для отправки сообщений"""
    i = i()

    def __init__(self, d, path):
        super().__init__(d, path)
        self.generated_keys = set(self.get_key_ids())
        self.author_device_jid = self.get_author_device_jid()
        self.chats = self.get_chats()

    def get_jids(self) -> dict[i.phone: i.jid]:
        data = self.execute(f"select user, _id from jid where type = 0 and server = 's.whatsapp.net'")
        return {phone: jid for phone, jid in data}

    def get_device_jid_row_id(self) -> dict[i.jid: i.receipt_device_jid_row_id]:
        data = self.execute(f"select user_jid_row_id, device_jid_row_id from user_device")
        return {user_jid_row_id: device_jid_row_id for user_jid_row_id, device_jid_row_id in data}

    def get_chats(self) -> dict[i.jid: (i.chat_id, i.hidden)] | None:
        data = self.execute(f"select jid_row_id, _id, hidden from chat")
        return {jid: (chat_id, hidden) for jid, chat_id, hidden in data}

    def update_chat(self, jid) -> None:
        self.execute(f"update chat set hidden = 0 where jid_row_id = {jid}")
        return None

    def insert_chat(self, jid: i.jid) -> dict[i.jid: i.chat_id]:  # использовать update
        if jid not in self.chats.keys():
            self.execute(f"""
            INSERT INTO chat(jid_row_id,hidden,subject,created_timestamp,display_message_row_id,last_message_row_id,last_read_message_row_id,last_read_receipt_sent_message_row_id,last_important_message_row_id,archived,sort_timestamp,mod_tag,gen,spam_detection,unseen_earliest_message_received_time,unseen_message_count,unseen_missed_calls_count,unseen_row_count,plaintext_disabled,vcard_ui_dismissed,change_number_notified_message_row_id,show_group_description,ephemeral_expiration,last_read_ephemeral_message_row_id,ephemeral_setting_timestamp,ephemeral_disappearing_messages_initiator,unseen_important_message_count,group_type,last_message_reaction_row_id,last_seen_message_reaction_row_id,unseen_message_reaction_count,growth_lock_level,growth_lock_expiration_ts,last_read_message_sort_id,display_message_sort_id,last_message_sort_id,last_read_receipt_sent_message_sort_id,has_new_community_admin_dialog_been_acknowledged,history_sync_progress)
            VALUES({jid},0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,NULL);
            """)
            chat_id = self._get_last_row_id('chat')
            self.chats.update({jid: (chat_id, 0)})
            return {jid: (chat_id, 0)}

    def insert_message(self, jid, chat_id: i.chat_id, message: str) -> dict[i.jid: (i.message_id, i.message_id)]:  # использовать update
        time = self._generator_unix_time()
        sort_id = self._get_last_sort_id('message')

        first_query = f"""  INSERT INTO message(chat_row_id,from_me,key_id,sender_jid_row_id,status,broadcast,recipient_count,participant_hash,origination_flags,origin,timestamp,received_timestamp,receipt_server_timestamp,message_type,text_data,starred,lookup_tables,message_add_on_flags, sort_id)
                            VALUES({chat_id[0]},1,'{self._generator_key_id()}',0,6,0,0,NULL,0,0,{time + random.randint(4, 15)},0,-1,7,NULL,0,0,0, {sort_id});
                        """
        # self.execute(first_query)
        firs_id = self._get_last_row_id('message')
        second_query = f""" INSERT INTO message(chat_row_id,from_me,key_id,sender_jid_row_id,status,broadcast,recipient_count,participant_hash,origination_flags,origin,timestamp,received_timestamp,receipt_server_timestamp,message_type,text_data,starred,lookup_tables,message_add_on_flags, sort_id)
                            VALUES ({chat_id[0]},1,'{self._generator_key_id()}',0,0,0,0,NULL,0,0,{time},0,-1,0,'{message}',0,0,0, {sort_id + 1});
                        """
        # self.execute(second_query)
        self.execute(first_query + second_query)
        second_id = self._get_last_row_id('message')

        return {jid: (firs_id, second_id)}

    def _generator_key_id(self) -> i.key_id:
        letters = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']
        while True:
            result_str = "".join(random.choice(letters) for _ in range(32))
            if result_str not in self.generated_keys:
                break
        self.generated_keys.add(result_str)
        return result_str

    def get_key_ids(self) -> list[i.key_id]:
        data = self.execute(f"select key_id, null from message")
        return [key_id[0] for key_id in data]

    def _generator_unix_time(self) -> i.unix_time:  # брать время устройства или программы? можно брать с помощью либы DAte и указывать мск время в utm
        now = datetime.datetime.now(datetime.timezone(datetime.timedelta(hours=3)))
        unix_time_ms = int(now.timestamp() * 1000)
        return unix_time_ms

    def get_author_device_jid(self) -> i.author_device_jid:
        data = self.execute(f"select distinct author_device_jid, null from message_details m join message mo on m.message_row_id = mo._id where mo.from_me = 1;")
        return data[0][0]

    def insert_message_details(self, message_id: i.message_id) -> None:
        """Принимает меньший message_id"""
        self.execute(f"""INSERT INTO message_details (message_row_id, author_device_jid) VALUES({message_id}, {self.author_device_jid});""")
        return None

    def insert_receipt_device(self, message_id: i.message_id, receipt_device_jid_row_id: i.receipt_device_jid_row_id) -> None:
        """Принимает больший message_id"""
        self.execute(f"""
        INSERT INTO receipt_device (message_row_id,receipt_device_jid_row_id,receipt_device_timestamp,primary_device_version) 
        VALUES({message_id}, {receipt_device_jid_row_id},NULL,NULL);""")
        return None

    def _get_last_row_id(self, table_name) -> int:
        data = self.execute(f"SELECT max(_id), null from {table_name};")
        return data[0][0]

    def _get_last_sort_id(self, table_name) -> int:
        data = self.execute(f"SELECT max(sort_id), null from {table_name};")
        return data[0][0]
